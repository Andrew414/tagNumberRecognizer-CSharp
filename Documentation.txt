Документация по лабораторному проекту
-------------------------------------

1 Компиляция проекта

    Проект написан на языке С#. Проект использует сторонние библиотеки, такие как OpenCV, OpenCVSharp.

    Версии библиотек:
        OpenCV          2.4.5 
        OpenCVSharp     2.4.5
    
    Порядок добавления библиотек:
        Необходимо настроить следующие переменные окружения:
            OPENCV_DIR=<каталог, в который установлена библиотека opencv>\build\x86\vc11
            PATH=%PATH%;%OPENCV_DIR%\bin
        Примечание: Вместо x86 можно использовать файлы для платформ, например x64. 
                    Однако тогда необходимо проследить, чтобы другие библиотеки, в том числе OpenCVSharp тоже были предназначены для x64.
        Примечание: Файлы из каталога vc11 предназначены для Visual Studio 2012. 
                    Для использования их с другой версией MSVS необходимо выбрать другую каталог,
                    например, vc10 для MSVS 2010 и т.д.
        
    Компиляция проекта осуществляется из среды Visual Studio 2012. Для компиляции под Unix системы ввести в консоли xbuild. 
    Для компиляции проекта необходимо:
        - склонировать (git clone) репозиторий с ресурса GitHub (http://github.com). 
          адрес репозитория - https://github.com/Andrew414/tagNumberRecognizer-CSharp
        - настроить все зависимости для проекта (ссылка на библиотеку OpenCVSharp, установить OpenCV 2.4.5)
        - открыть проект (csproj в Visual Studio 2012 
        - запустить проект (F5, Ctrl+F5, Ctrl+Shift+B).
        
    Для запуска проекта на Unix системах необходимо:
        - склонировать (git clone) репозиторий с ресурса GitHub (http://github.com). 
          адрес репозитория - https://github.com/Andrew414/tagNumberRecognizer-CSharp
        - необходимо прописать NUNIT_PATH путь где лежит библиотека NUnit
        - зайти в папку deployment
        - найти скрипт linux.sh (для Linux систем, пока только для Ubuntu) или mac.sh(для MacOS)
        - запустить скрипт в командной строке (путь к фалу/linux.sh или путь к фалу/mac.sh)
        - переместить файлы OpenCVSharp.dll и OpenCVSharp.dll.config в каталог bin/release.
        
    Если в командной строке указать имя видео-файла, то программа будет работать с готовым видео, а не записывать изображение с камеры.
    Запуск Unit тестов осуществляется из среды Visual Studio(скомпилируем проект нажатием F7, запустить Nunit-86.exe, запустить проект на тестирование).
    
2 Очистка проекта

	Все временные файлы, промежуточные и окончательные результаты построения проекта содержатся в каталогах \bin\ и \obj\
    Соответственно, для очистки проекта необходимо удалить эти папки.
    Стоит также отметить, что репозиторий настроен таким образом, что даже если эти папки присутствуют, они не будут добавлены в git.
    
3 Функциональность проекта

	Приложение позволяет:
        - захватывать видео с веб-камеры;
        - выделять на нем автомобильный номер;
        - распозновать цифры и буквы на номере;
        - сохранять историю распознанных номеров. 
    
4 Структура проекта
    Пользовательский интерфейс
        Классы Program и TagrecSForm - пользовательский интерфейс.
    
    Интерфейсы 
        IPlateFinder, IPlateReader, ISignReader - определяют необходимые методы для распознавания номера.
        
        IPlateFinder позволяет найти на картинке контур автомобильного номера.
            Методы: 
                FindRectangle   - ищет контур автомобильного номера
                Transform       - преобразовывает картинку в другое представление (grayscale, binary, blur, ...)
        IPlateReader позволяет распознать цифры и буквы на автомобильном номере (картинке с соотношением сторон 4.4/1)
            Методы:
                ReadPlate       - распознает номер и возвращает строку с его содержимым.          
            Связи:
                Содержит экземпляр интерфейса ISignReader.
        ISignReader  распознает один символ (цифру либо букву)
            Методы:
                ReadSign        - возвращает символ, переданный как картинка.
                
    Классы-заглушки (для тестирования)     
        StupidPlateFinder
            Всегда "находит" на изображении номер, в левом верхнем углу, размеров 200*50
            Не применяет никакого преобразования к картинке в методе Transform
            
        StupidPlateReader
            Всегда "распознает" номер "4142 AB-1", все зависимости от реального содержимого изображения
            
        StupidSignReader
            Всегда находит на картинке символ "A"
    
    Классы-реализации интерфейсов распознавания
        MARPlateFinder
            Ищет горизонтальный (угол наклона не более 5 градусов) прямоугольник с соотношением сторон ~4.4/1 методом MinAreaRect (MAR)
            Преобразования при поиске: 
                image -> grayscale -> blur -> binary (оригинальное изображение -> оттенки серого -> размытие Гаусса -> черно-белое изображение)
            Преобразования при трансформации:
                image -> grayscale -> histequal (оригинальное изображение -> оттенки серого -> эквализация гистограммы)
            Возможны другие преобразования трансформации при изменении исходного кода
            
        NLPlateReader
            Ищет все цифры и буквы номера и отправляет их на дальнейшую обработку в настраиваемый ISignReader (по умолчанию - MaskSignReader)
            Метод поиска - поиск по контурам с фильтром контуров. 
            После фильтрации стаются только те контуры, высота которых соответствует 2/3 от высоты всего номерного знака.
            Только в том случае, когда класс находит на изображении 7 букв и цифр (NNNN LL-N, где N - цифра, L - буква), он пытается распознать конкретные цифры и буквы с помощью ISignReader
    
        MaskSignReader
            Распознает цифру или букву методом проверки по маске.
            Класс имеет стандартную библиотеку шаблонов (паттернов) цифр и букв, используемых в автомобильных номерах.
            Поиск производится операцией EQ/NXOR. 
            Алгоритм распознавания:
                - шаблон для сравнения вместе с самим изображением приводятся к двуцветному режиму.
                - считается количество совпадений цвета для каждого шаблона (пикселей, которые либо оба белые и в шаблоне, и на изображении, либо оба черные)
                - выбирается шаблон с наибольшим количеством совпадений для каждого распознаваемого изображения
    
